<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soft Elixir</title>
  <link rel="stylesheet" href="stylesheets/dev.css">
</head>
<body>
  <div class="container">
    <header>
      <a href="."><h1>Soft Elixir</h1></a>
      <nav>
        <div>{<s><a href="#">demo</a></s>}</div>
        <div>{<a href="features">features</a>}</div>
        <div>{<a href="dev">dev notes</a>}</div>
      </nav>
    </header>
    <nav class="vertical">
  <div>{<a href="#rendering">rendering</a>}</div>
  <div>{<a href="#synthesis">synthesis</a>}</div>
</nav>

<h2 id="rendering">Rendering</h2>
<p>The pattern editor is the heart of a tracker-like sequencer. Entering notes, automating digital effects, sequencing patterns... 99% of the work that goes into composing a track happens inside this one component.</p>
<p><img src="/assets/soft-elixir-2.png" alt="Soft Elixir"></p>
<p>As well as handling a lot of data, it must also be snappy and responsive at rates of over 200 BPM. This is not a good fit for DOM-based rendering.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas">Off-screen canvas rendering</a> has obvious advantages. Expensive animation operations can be pushed to a separate rendering thread with a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">web worker</a> in order to protect the main thread.</p>
<p>The main obstacle to overcome is communication between these two threads, which should be as lightweight as possible.</p>
<p>Each time the pattern editor needs to be updated, the rendering thread should draw the currently visible block of data to the canvas. What&#39;s the most efficient way of providing access to this data?</p>
<p><strong>Solution 1: serialising objects</strong></p>
<p>The simplest solution for sending data to the rendering thread is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage">postMessage</a> method.</p>
<p>Using this method, we can send any data we like from the main thread to the rendering thread, so long as it&#39;s supported by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clone algorithm</a>.</p>
<p>However, this is also the slowest solution. A lot of computation time is wasted serialising objects on the main thread and deserialising them on the rendering thread with each update.</p>
<p><strong>Solution 2: transferable objects</strong></p>
<p>Instead of serialising objects, why not just transfer ownership entirely from the main thread to the rendering thread?</p>
<p>The postMessage method allows us to specify which of the objects it&#39;s been handed are <em>transferable</em>, meaning that ownership of their allocated memory should be transferred between threads.</p>
<p>As such, data objects aren&#39;t serialised or copied as in the previous solution. The only thing sent with the call to postMessage is a reference to a location in memory. However, as part of the transferring process, we also lose access to the objects in the main thread. We can no-longer access or write to the transferred blocks of memory.</p>
<p>Just as with the previous solution, only certain items are supported by the <em>transferable</em> protocol. Our data can be represented by an array of primitive types, so <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a> makes the most sense in this case. Unfortunately, this comes with the additional overhead of using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataViews</a> to read and write to our shared block of memory.</p>
<p><strong>Solution 3: SharedArrayBuffers</strong></p>
<p>With <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffers</a>, we can give both threads read/write access to the same block of memory. However, the data type limitations of the previous solution still apply.</p>
<p>Additionally, the problem of avoiding <a href="https://en.wikipedia.org/wiki/Race_condition">race conditions</a> needs to be navigated.</p>
<p><strong>Solution 4: keep it simple, stupid</strong></p>
<h2 id="synthesis">Synthesis</h2>

  </div>
</body>

  <script src="js/dev.js"></script>

</html>